# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Datachecker
                                 A QGIS plugin
 riool datachecker
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-01-21
        git sha              : $Format:%H$
        copyright            : (C) 2020 by OAS-De Groote Lucht
        email                : o.claassen@schiedam.nl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, Qt
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QAction,QFileDialog
from qgis.core import QgsProject,QgsVectorLayer,QgsLayerTreeLayer
# Initialize Qt resources from file resources.py
from .resources import *
import os
from osgeo import ogr
# Import the code for the DockWidget
from .Datachecker_dockwidget import DatacheckerDockWidget
import os.path
from .tool_quality_checks.scripts import run_scripts
from pathlib import Path, PureWindowsPath

#Debugging in vs : https://gist.github.com/AsgerPetersen/9ea79ae4139f4977c31dd6ede2297f90

velden = {'min_levels', 'max_levels', 'min_length','max_length', 'max_verhang','min_dekking', 'hoogte_verschil', 'min_dimensions', 'max_dimensions', 'padding_manhole'}     


class SettingsObjectPlugin(object):
    """Contains the settings from the ini file"""

    def __init__(self):
        self.origin = "plugin"
        
class Datachecker:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'datachecker_{}.qm'.format(locale))
        #print(locale_path)

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Riooldatachecker')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'Datachecker')
        self.toolbar.setObjectName(u'Datachecker')

        #print "** INITIALIZING Datachecker"

        self.pluginIsActive = False
        self.dockwidget = None


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Datachecker', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/oas-dgl-datachecker/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Riooldatachecker'),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING Datachecker"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD Datachecker"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Riooldatachecker'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    #--------------------------------------------------------------------------
    def pb_select_dc_folder(self):
        foldername = QFileDialog.getExistingDirectory()
        self.dockwidget.folderNaam.setText(foldername)
        if foldername:
            self.dockwidget.listChecks.clear()
            self.fill_checks_list()
    
    def fill_checks_list(self):
        foldername= self.dockwidget.folderNaam.text()
        geopackageList =[]
        for file in os.listdir(foldername):
            if file.endswith(".gpkg"):
                geopackageList.append(file)
        self.dockwidget.listChecks.addItems(geopackageList)
    
    def laad_gpkg(self):
        fileName= self.dockwidget.listChecks.selectedItems()
        # dictionary with layer_names of gpkg and potential group name in QGIS
        group_mapping = {'leiding': 'leidingen', 'put': 'putten', 'profiel': 'profielen'}
        
        if len(fileName)>0:
            root=QgsProject.instance().layerTreeRoot()
            for gpkg in fileName:
                foldername= self.dockwidget.folderNaam.text()
                file = os.path.join(foldername,gpkg.text())
                conn = ogr.Open(file)
                
                for key, value in group_mapping.items():
                    group = root.addGroup(value)
                    for layer in conn:
                        if layer.GetFeatureCount()>0:
                            combined=file+"|layername={}".format(layer.GetName())
                            vlayer=QgsVectorLayer(combined,layer.GetName(),"ogr")                        
                            QgsProject.instance().addMapLayer(vlayer,False)
                            if layer.GetName().split('_')[0]==key:
                                group.addLayer(vlayer)    
                            if not vlayer.isValid():
                                print('failed to load')
                        
                            
        root = QgsProject.instance().layerTreeRoot()
        for child in root.children():
            if child.name() in group_mapping.values():
                for child2 in child.children():
                    if isinstance(child2, QgsLayerTreeLayer):
                        child2.setCustomProperty("showFeatureCount", True)
                        
    def pb_select_exp_folder(self):
        foldername = QFileDialog.getExistingDirectory()
        self.dockwidget.folderNaam_export.setText(foldername)
        if foldername:
            self.dockwidget.listExport.clear()
            self.fill_export_list()  
                            
    def fill_export_list(self):
        foldername= self.dockwidget.folderNaam_export.text()
        exportList =[]
        for file in os.listdir(foldername):
            if file.endswith(".shp"):
                exportList.append(file)
        self.dockwidget.listExport.addItems(exportList)                        

    
    def laad_qml_styling(self):
        if self.dockwidget.qmlBeheerderBox.checkState()==2:
            folder = 'StylingBeheerder'
        elif self.dockwidget.qmlModelleurBox.checkState()==2:
            folder = 'StylingModelleur'
        else:
            return
            
        for layer in QgsProject.instance().mapLayers().values():

            scriptLocatie =os.path.dirname(os.path.realpath(__file__))
            qmlpad = os.path.join(scriptLocatie, folder, layer.name())+'.qml'
            layer.loadNamedStyle(qmlpad)
            layer.triggerRepaint()
            
    def save_folderchecks(self):
        folderchecks = os.path.realpath(self.dockwidget.folderNaam.text())              
        self.save_qsetting('paths', 'folderchecks',folderchecks)
            
    def save_leidingfile(self):
        leidingfile = os.path.realpath(self.dockwidget.leidingFile.filePath())              
        self.save_qsetting('paths', 'leidingfile',leidingfile)        
        
    def save_putfile(self):
        # putfile = os.path.dirname(os.path.realpath(self.dockwidget.putFile.filePath()))   
        putfile = os.path.realpath(self.dockwidget.putFile.filePath())
        self.save_qsetting('paths', 'putfile',putfile)
              
        
    def draai_de_checks(self):       
        
        settings = SettingsObjectPlugin()
        settings.s="localhost"
        settings.host="localhost"
        settings.database="work_test_quality_checks"
        settings.port="5432"
        settings.username="postgres"
        settings.password="postgres"
        settings.dropdb = True
        settings.createdb = True
        settings.import_type = False
        settings.import_type = 'gbi'
        settings.checks = True
        
        putfile = self.get_qsetting('paths', 'putfile')
        settings.manhole_layer = putfile
        leidingfile = self.get_qsetting('paths', 'leidingfile')
        settings.pipe_layer = leidingfile
        
        settings.dem = os.path.realpath('C:\\Users\onnoc\AppData\Roaming\QGIS\QGIS3\profiles\default\python\plugins\OASDGLDatachecker\tool_quality_checks\test\data\schiedam-test\dem_schiedam_test.tif')
        self.instellingen_ophalen(settings)
        
        print(settings.__dict__)
        run_scripts(settings)
        settings.dropdb = False
        settings.createdb = False
       
        
    def slider_function(self,value):
        layer = self.iface.mapCanvas().currentLayer()        
        #print(layer.renderer().type()) 
        #for field in layer.renderer().symbol().symbolLayer(0):
                #print(field.name(), field.typeName())
            #layer.renderer().symbol().symbolLayer(0).setSize(value)
        if layer.renderer().symbol().type()==1: # Lijnen
            layer.renderer().symbol().symbolLayer(0).setWidth(value)
            #print(layer.renderer().symbol().type())
            
        elif layer.renderer().symbol().type()==0:  # symbolen  
            layer.renderer().symbol().symbolLayer(0).setSize(value)
        layer.triggerRepaint()
        print(layer.name())
        #print(value)
        
    def instellingen_opslaan(self):           
        for veld in velden:
            box = getattr(self.dockwidget, veld)
            waarde = box.value()
            # print(veld, waarde)            
            self.save_qsetting('Instellingen', veld, waarde)
    
    def instellingen_ophalen(self, settings):
        s= QSettings()
        group = 'Instellingen'
        for veld in velden:
            value = s.value( 'OASDGLDatachecker/' + group + '/' + veld)
            setattr(settings, veld, value)
            print(value)  

    def save_qsetting(self, group, key, value):
        # file waar het opgelsagen wordt: C:\Users\onnoc\AppData\Roaming\QGIS\QGIS3\profiles\default\QGIS\QGIS3.INI
        s= QSettings()        
        s.setValue( 'OASDGLDatachecker/' + group + '/' + key, value) 
        test = s.value( 'OASDGLDatachecker/' + group + '/' + key)
        
    def get_qsetting(self, group, key):
        s= QSettings()
        value = s.value( 'OASDGLDatachecker/' + group + '/' + key)
        print(value)  
        return(value)
        
    def initialize_paths(self):
        foldernaam=self.get_qsetting('paths', 'folderchecks')
        if foldernaam:
            foldernaam=Path(foldernaam)
            self.dockwidget.folderNaam.setText(str(foldernaam))
            self.fill_checks_list()
        
        
    def run(self):
        """Run method that loads and starts the plugin"""
        if not self.pluginIsActive:
            self.pluginIsActive = True
            
            #print "** STARTING Datachecker"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = DatacheckerDockWidget()
            
            self.dockwidget.ObjectSlider.valueChanged.connect(self.slider_function)
            self.dockwidget.applyStylingButton.clicked.connect(self.laad_qml_styling)
            self.dockwidget.selectFolderButton.clicked.connect(self.pb_select_dc_folder)            
            self.dockwidget.folderNaam.textChanged.connect(self.save_folderchecks)
            #self.dockwidget.folderNaam.editingFinished.connect(self.fill_checks_list)
            self.dockwidget.InladenGpkgButton.clicked.connect(self.laad_gpkg)
            
            self.dockwidget.selectFolderButton_export.clicked.connect(self.pb_select_exp_folder)
            ##self.dockwidget.linePutten.dropevent.connect(over
            
            self.dockwidget.leidingFile.fileChanged.connect(self.save_leidingfile)
            self.dockwidget.putFile.fileChanged.connect(self.save_putfile)            
            self.dockwidget.DatachecksButton.clicked.connect(self.draai_de_checks)
            self.dockwidget.instellingenopslaan.clicked.connect(self.instellingen_opslaan)
            
                       
            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dockwidget.show()
            self.initialize_paths()
